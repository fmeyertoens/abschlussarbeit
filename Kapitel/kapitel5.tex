\chapter{Vergleich}

\section{Abfrageflexibilität}
\begin{itemize}
  \item nicht nur Abfrage (GET) sondern auch Änderungsoperationen (POST,\dots)
  \item GraphQL
  \begin{itemize}
    \item keine Wildcards (alle Felder eines Objekts)
    \item als Abfragesprache gedacht
    \item unterscheidet Feldselektion, Sortieren, Filtern, Optionen
    \item keine Syntax für Sortieren/Filtern, aber Möglichkeit über Feldargumente
    \item Bsp: height (unit:FOOT)
    \item sehr anpassbar für verschiedene Apps bzw. öffentliche API (Anforderungen unbekannt)
    \item include ist quasi Pflicht, effizient und konsistent
    \item an Query sind Performanceprobleme evtl.\ schwer erkennbar (siehe Tools)
  \end{itemize}
  \item REST
  \begin{itemize}
    \item oft einfacher Anfang. Mit steigender Komplexität werden Abfragesprachen typische Konstrukte eingebaut
    \item fields=`` '' für Feldselektion
    \item field=`` '' zum Filtern
    \item sort=[field],sort-dir=desc zum Sortieren
    \item option=`` '' für Optionen
    \item includes empfohlen bei JSON:API, aufbrechen von HATEOAS\@?
    \item includes oder extra Endpunkt ist Entwurfsentscheidung
    \item Anforderungen für Client App können spezifisch werden, extra API pro Client
  \end{itemize}
  \item Upload ist schwierig für GraphQL (serialization), REST kann multipart/form-data header nutzen
\end{itemize}
Bei der Entwicklung von Client-Anwendungen ist die Flexibilität der genutzten API ein entscheidender Einflussfaktor.
Dabei steht besonders die Flexibilität für das Generieren von Abfragen im Vordergrund, aber auch von Operationen zum Modifizieren von Ressourcen.\par

GraphQL wurde als Abfragesprache entwickelt.
Eines der Entwicklungsziele ist es, dass eine Clientanwendung mit einer einzigen Abfrage alle für eine Ansicht nötigen Daten erhalten kann.
Der Server gewährt Zugriff auf das Datenschema, welches alle verfügbaren Daten und deren Relationen darstellt, sowie die Einstiegspunkte (Root Query), auf deren Basis ein Client seine Anfrage aufbauen kann.
Das Schema stellt den Rahmen für alle Abfragen dar.
Alle Daten, die der Server zur Verfügung stellt, werden durch Typen und deren Felder repräsentiert.
Jedes Feld, welches eine Clientanwendung erhalten möchte, muss in der Query angegeben werden.
Es existiert keine Möglichkeit alle Felder eines Typs zu erhalten ohne jedes davon anzugeben.
Der Client ist damit eng an das Schema gekoppelt, erhält aber auch nur die Daten, die tatsächlich angefragt wurden.
Die Möglichkeit eines GraphQL-Servers beliebige Abfragen innerhalb des Schemas auszuwerten eignet sich besonders für öffentliche APIs, bei denen dem API-Entwickler die individuellen Anforderungen und damit die Abfragen verschiedenster Anwendungen, im Voraus nicht bekannt sind.
Die Relationen zwischen den Datentypen werden durch das Schema festgelegt.
Eine Anfrage kann jedoch beliebig viele, unabhängige Queries beinhalten, \zB{} um verschiedene Daten zu erhalten, die in keiner Beziehung zueinander stehen oder deren Beziehung durch das Schema nicht dargestellt wird.
Der Server kann für jedes Feld Parameter anbieten, welche die Auswertung des Feldwertes verändern. Über solche Feldargumente können Optionen, die Geschäftslogik darstellen, aber auch allgemeine Abfragefunktionen, wie \zB{} Sortieren und Filtern zur Verfügung gestellt werden.\par
Während das Anfragen von Daten sehr viel Flexibilität für Clients bietet, ist das Modifizieren von Ressourcen nach Konvention nur über einzelne Mutations möglich.
Üblicherweise wird für jede Operation (Erstellen, Verändern und Löschen) einer Ressource eine separate Mutation zur Verfügung gestellt, welche durch den Namen eindeutig identifiziert wird.
Die Antwort auf eine Mutation kann wieder ein Objekt sein und genutzt werden um das Resultat der Operation zu übermitteln oder den neuen Stand der Ressource abzufragen.
\par

In einer REST API ist jede Ressource über einen separaten Endpunkt erreichbar.
Die Antwort auf einen GET Request an einen Endpunkt enthält alle Felder der Ressource bzw.\ die komplette Repräsentation.
In Beziehung stehende Daten, die nicht Teil einer Ressource sind, müssen über mehrere Requests vom Server angefragt werden.
Der Grundgedanke von HATEOAS ist, dass diese verbundenen Ressourcen Verweise aufeinander enthalten, wodurch ihre Beziehung dargestellt wird.
Das Zusammenbauen von Requests anhand der Links in erhaltenen Ressourcen ermöglicht große Flexibilität, erfordert jedoch dass Daten erst ausgewertet werden müssen und danach erst neue Anfragen abgesetzt werden können.
Dadurch ist das Datenmodell nicht durch ein Schema vorgegeben, sondern kann zur Laufzeit geändert und explorativ genutzt werden, da es selbstdokumentierend ist.
Oftmals ist bei der Entwicklung von Clientanwendungen die erforderliche Datenstruktur jedoch bekannt und ist es wünschenswert möglichst alle benötigten Informationen von wenigen Endpunkten zu erhalten, um die Performance zu steigern.
Dazu gibt es verschiedene Ansätze, wie der Query-String einer URI genutzt werden kann, um in Beziehung stehende Daten mit einem einzigen Request von einem Endpunkt zu erhalten.
Weder REST noch HTTP spezifizieren Syntax und Semantik des Query Strings bzw.\ betrachten diese als Implementierungsdetail. 
Query-Parameter und Matrixparameter werden gebraucht, um die Möglichkeiten von Abfragesprachen für REST zu implementieren.
Sie ermöglichen \zB{} die gewünschten Felder des angefragten Objektes, ein Feld nach dem sortiert, oder ein Feld und Wert nach dem gefiltert werden soll, anzugeben.
Über sogenannte \enquote{includes} lassen sich bei JSON:API verbundene Objekte in die Antwort einbeziehen.
Includes oder sind außerdem eine effektive Lösung für das N+1 Problem.
Diese speziellen Auswertungen des Query-Strings müssen durch den REST Server angeboten werden und sind aus Entwurfssicht ein Tausch von erhöhter Abfragekomplexität und Clientflexibilität gegen Serverperformance.
Ein Endpunkt kann alle Methoden zum Abfragen und Ändern einer Ressource bereitstellen und durch die HTTP Verben semantisch unterscheiden.
Das Veröffentlichen einer neuen Ressource geschieht durch das Einführen eines neuen Endpunktes.

\section{Versionierung und Weiterentwicklung}
\begin{itemize}
  \item GraphQL
  \begin{itemize}
    \item neue Felder hinzufügen ohne existierende Queries zu beeinflussen
    \item neue Felder nicht automatisch gesendet
    \item Felder als deprecated markieren → Tool kann Entwickler warnen
    \item Monitoring auf Feldlevel möglich
  \end{itemize}
  \item REST
  \begin{itemize}
    \item Monitoring: werden sparse fieldsets oder includes verwendet können genutzte Felder aufgezeichnet werden
    \item neue Version, neuer Endpunkt example.com/v2/contacts/\dots
    \item für kleine Veränderungen ungeeignet
  \end{itemize}
\end{itemize}

\section{Datenaufkommen/Netzwerklast}
\begin{itemize}
  \item Transfer, Verarbeiten und Speichern unnötiger Daten (Felder) sollte vermieden werden
  \item GraphQL
  \begin{itemize}
    \item automatisch kleinstmöglicher Request
    \item Query muss an Server gesendet werden
  \end{itemize}
  \item REST
  \begin{itemize}
    \item standardmäßig gesamte Repräsentation
    \item viele APIs bieten Feldselektion an (Partials)
    \item query string enthält Feldselektion nach bestimmter Syntax
    \item je komplexer, desto mehr Daten
    \item jede Ressource ist extra Endpunkt
    \item für mehrere Ressourcen müssen mehrere Requests gemacht werden, n+1 Problem
    \item includes beziehen verbundene Daten in Response ein → ein Request für mehrere Ressourcen
  \end{itemize}
  \item GraphQL und REST Partials unterscheiden Objekt und Array nicht → Wissen über API notwendig um Performance einzuschätzen
  \item mehr Daten um Request genauer zu machen, sinnvoll um deutlich weniger Daten als Response zu erhalten
\end{itemize}

\section{Caching}
\begin{itemize}
  \item Flexibilität gegen Caching: je spezieller die Abfrage, desto schwieriger (weniger sinnvoll) caching
  \item nicht Antwort direkt cachen (HTTP), sondern manuell Objekte anhand ID cachen (JavaScript)
  \item REST
  \begin{itemize}
    \item Browser HTTP caching automatisch genutzt
    \item Caching basierend auf Endpunkt
    \item URL ist cache ID für die Ressource
    \item ermöglicht HTTP cache proxies
    \item je spezieller der query string, desto weniger cache Treffer
  \end{itemize}
  \item GraphQL
  \begin{itemize}
    \item POST response wird normalerweise nicht gecacht
    \item standardmäßig keine ID für caching vorhanden. Empfehlung: API sollte ID pro Objekt bereitstellen
  \end{itemize}
\end{itemize}

\section{Batching/Deduping}
\begin{itemize}
  \item GraphQL queries können parallel ausgewertet werden, Mutations nicht
\end{itemize}

\section{Fehlerbehandlung}

\section{Sicherheit}

\section{Kosten}

\section{Lernkurve, Fehlersuche, Community}

\section{Bibliotheken und Tools}
\begin{itemize}
  \item GraphQL
  \begin{itemize}
    \item offizielle Spezifikation vorhanden
    \item Referenzimplementierung in JavaScript
    \item Zusatztools von Facebook (Dataloader, Relay)
    \item Tool kann Abfragekomplexität zu Entwicklungszeit ermitteln (mit vergangenen Messwerten)
  \end{itemize}
\end{itemize}
