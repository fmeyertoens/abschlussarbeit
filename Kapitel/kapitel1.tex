\chapter{Einleitung}

\section{Motivation und Zielstellung}
Das Internet und Web-Anwendungen unterliegen einem starken Wandel.
Die Kommerzialisierung, zunehmende Verbreitung und Erweiterung der Möglichkeiten haben zu einer veränderten Nutzung und Entwicklung von Internetanwendungen beigetragen.
Vom Netzwerk zum Teilen von Hypertextdokumenten ist es zur Plattform für alle Arten interaktiver betrieblicher und sozialer Software geworden.
\par
Um der zunehmenden Größe, Komplexität und mangelnden Wartbarkeit der Anwendungen Herr zu werden, hat sich auch in der Webentwicklung der anerkannte Grundsatz \enquote{Teile und Herrsche} durchgesetzt.
Namentlich ist der Trend von sogenannter monolithischer zu service-orientierter Software zu beobachten.
Verbesserungen in der Skriptausführung von Webbrowsern und die Weiterentwicklung von JavaScript selbst hatte außerdem zur Folge, dass immer mehr Teile der Programme auf dem Client ausgeführt werden.
Zeuge dieser Entwicklung sind die vielen JavaScript Frameworks (z.B. Angular, React, Vue), welche besonders innerhalb der letzten 10 Jahre populär geworden sind und mittlerweile zum Standard der Webentwicklung gehören, sowie Projekte wie Electron und NativeScript, welche Webtechnologien nutzen, um native Anwendungen zu entwickeln~\cite[vgl.][]{SOsurvey}.
Mit diesen Frameworks entwickelte Single Page Applications (SPA) generieren Ansichten und Dialoge auf Basis von Daten, welche über Web Application Programming Interfaces (API) mit dem Server ausgetauscht werden.
Oft kommunizieren Anwendungen mit einer Vielzahl von Webservices, \zB{} um unternehmensinterne oder externe Datenquellen oder Dienste zu integrieren.
\par
Um eine einheitliche Kommunikationsschnittstelle für die Interaktion von Clientanwendungen und Webservices zu schaffen, werden APIs häufig nach dem Representational State Transfer Architekturkonzept (REST) entwickelt.
Da REST aber nur Rahmenbedingungen und die Grundgedanken für Web-APIs liefert, finden sich in der Praxis viele Formate und Modelle, welche versuchen Implementierungsdetails und Best-Practices auszuführen.
Die Bezeichnung REST-API ist somit aufgeweicht worden und Entwickler sind, aufgrund mangelnder Standards, zu API spezifischen Anpassungen gezwungen.
\par
GraphQL wurde 2015 von Facebook veröffentlicht und bringt eine Spezifikation und Abfragesprache für die Client-Server Kommunikation.
Die Implementierung einer GraphQL-API unterscheidet sich gravierend von bestehenden REST-APIs.
Mittlerweile existieren aber wichtige Entwicklerwerkzeuge und die ersten GraphQL-APIs haben sich in der Praxis bewährt~\cite[vgl.][]{GitHubAPI}.
\par
Die vorliegende Arbeit soll mehrere Fragen bezüglich der beiden Ansätze für bestehende Web-APIs und Neuentwicklungen klären:
\begin{enumerate}
  \item Welche Vorteile bietet GraphQL\@?
  \item Welche Probleme entstehen erst durch GraphQL\@?
  \item Für welche Anwendungszwecke kann eine GraphQL-API eine REST-API ersetzen?
  \item Ist ein gemeinsamer Einsatz der beiden Ansätze möglich und sinnvoll?
\end{enumerate}

\section{Aufbau der Arbeit}
Um die API Ansätze REST und GraphQL zu vergleichen soll zunächst die zugrundeliegende Client-Server Architektur betrachtet werden.
Weiterhin muss der Begriff des Application Programming Interface (API) allgemein und speziell im Zusammenhang mit dem Web definiert werden.
Die REST Architektur stellt seit ihrer Erklärung im Jahr 2000 die Grundlage für viele Webanwendungen und APIs dar, wurde aber über die Jahre verschieden interpretiert und standardisiert.
Erst 2015 wurde GraphQL als Alternative veröffentlicht.
Die Grundgedanken beider Ansätze und ihre Implementierung werden daher nach ihrer chronologischen Reihenfolge untersucht.
Anschließend soll im Vergleich festgestellt werden, wie die Technologien die klassischen Probleme bei der API Entwicklung lösen und welche Vorteile und Probleme erkennbar sind.
Zum praktischen Vergleich wurde eine Single-Page Anwendung und jeweils eine REST- und GraphQL-Serveranwendung entwickelt, mit denen verschiedene API Szenarien dargestellt und die Performance gemessen werden kann.
Aus diesen Ergebnissen sollen die zuvor genannten Forschungsfragen beantwortet werden, bevor abschließen auch auf den kombinierten Einsatz der beiden Technologien eingegangen wird.
