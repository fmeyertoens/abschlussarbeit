\section{Vorbetrachtungen}
\subsection{Client-Server Architektur}
\begin{itemize}
  \item Client-Server ist ein verteiltes System
  \item Zwischen Client und Server geschieht Nachrichtenaustausch
  \item Client fordert eine Operation vom Server an. Server sendet Resultat der Operation an den Client zurück.
  \item Client initiiert die Interaktion. Server reagiert.
  \item Mehrere Clients können den gleichen Server nutzen. Abbildung aus `Grundkurs verteilte Systeme'!
  \item Client kann mehrere Server benutzen. Server kann in anderer Interaktion selbst zum Client/Vermittler werden.
  \item Vorteile
    \begin{itemize}
      \item getrennte Entwicklung
      \item unabhängige Ausfälle
      \item Festgelegte Rollenverteilung: Client ist Konsument. Server ist Produzent.
    \end{itemize}
  \item Herausforderung: einheitliches Kommunikationsprotokoll
\end{itemize}

\subsection{Web APIs}
\begin{itemize}
  \item API bezeichnet Application Programming Interface
  \item Grundsatz ist die Kommunikation zweier Programme zur Konsumierung von anderem Quellcode, Abstraktion und Verstecken von Implementierungsdetails und Komplexität.
  \item Frameworks und Bibliotheken vieler Programmiersprachen bieten oft benötigte Funktionalität. Kommunikation besteht aus Aufruf mit Parametern und Antwort mit Ergebnis.
  \item Die Arbeit beschäftigt sich nur mit API von verteilten Systemen.
  \item Hauptaugenmerk auf Systemen mit Fat-Client. Großer Teil der Anwendungslogik auf Clientseite. Server dient als Datenspeicher.
  \item Popularität von Cloudservices und öffentlichen APIs bzw. Interaktion mit externen Services
\end{itemize}

\subsection{Abgrenzung zu anderen Web API Ansätzen}
\begin{itemize}
  \item SOAP (Simple Object Access Protocol), XML basiert
  \item RPC (Remote Procedure Call), Zentraler Punkt ist das Aufrufen von Anwendungslogik auf dem Server, nicht Datentransport.
\end{itemize}
